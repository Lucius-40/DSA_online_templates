#include<bits/stdc++.h>
#include "hash1.hpp"
#include "hash2.hpp"
#include "utils.hpp"

using namespace std;


int main() {
    const int NUM_INSERTIONS = 10000;
    const int NUM_SEARCHES = 1000;
    
    
    vector<string> keys = generate_unique_words(NUM_INSERTIONS, 10);
    
    random_device rd;
    mt19937 gen(42); 
    shuffle(keys.begin(), keys.end(), gen);
    
    vector<string> search_keys;
    for (int i = 0; i < NUM_SEARCHES; i++) {
        search_keys.push_back(keys[i]);
    }
    

    
    // chain
    Hash1Impl::HashTable_Chaining<string, int> h1_chain;
    for (int i = 0; i < keys.size(); i++) {
        h1_chain.insert(keys[i], i + 1);
    }
    
    
    for (const string& key : search_keys) {
        int val;
        h1_chain.search(key, val);
    }

    
    // Double Hashing
    Hash1Impl::HashTable_DoubleHashing<string, int> h1_double;
    for (int i = 0; i < keys.size(); i++) {
        h1_double.insert(keys[i], i + 1);
    }
    
    for (const string& key : search_keys) {
        int val;
        h1_double.search(key, val);
    }
    

    
    // Custom Probing
    Hash1Impl::HashTable_CustomProbing<string, int> h1_custom;
    for (int i = 0; i < keys.size(); i++) {
        h1_custom.insert(keys[i], i + 1);
    }
    
    for (const string& key : search_keys) {
        int val;
        h1_custom.search(key, val);
    }
    

    
    
  
    // Chaining
    Hash2Impl::HashTable_Chaining<string, int> h2_chain;
    for (int i = 0; i < keys.size(); i++) {
        h2_chain.insert(keys[i], i + 1);
    }
    
    for (const string& key : search_keys) {
        int val;
        h2_chain.search(key, val);
    }
    

    // Double Hashing
    Hash2Impl::HashTable_DoubleHashing<string, int> h2_double;
    for (int i = 0; i < keys.size(); i++) {
        h2_double.insert(keys[i], i + 1);
    }
    
    for (const string& key : search_keys) {
        int val;
        h2_double.search(key, val);
    }

    
    Hash2Impl::HashTable_CustomProbing<string, int> h2_custom;
    for (int i = 0; i < keys.size(); i++) {
        h2_custom.insert(keys[i], i + 1);
    }
    
    for (const string& key : search_keys) {
        int val;
        h2_custom.search(key, val);
    }
    

    
  
    cout << left << setw(20) << "Scheme" 
         << right << setw(15) << "Hash1 Colls" 
         << setw(18) << "Hash1 Avg Hits"
         << setw(18) << "Hash2 Colls"
         << setw(18) << "Hash2 Avg Hits" << endl;
    cout << string(89, '-') << endl;
    
    cout << left << setw(20) << "Chaining" 
         << right << setw(15) << h1_chain.getCollisions()
         << setw(18) << fixed << setprecision(2) << h1_chain.getAvgHits()
         << setw(18) << h2_chain.getCollisions()
         << setw(18) << fixed << setprecision(2) << h2_chain.getAvgHits() << endl;
    
    cout << left << setw(20) << "Double Hashing" 
         << right << setw(15) << h1_double.getCollisions()
         << setw(18) << fixed << setprecision(2) << h1_double.getAvgHits()
         << setw(18) << h2_double.getCollisions()
         << setw(18) << fixed << setprecision(2) << h2_double.getAvgHits() << endl;
    
    cout << left << setw(20) << "Custom Probing" 
         << right << setw(15) << h1_custom.getCollisions()
         << setw(18) << fixed << setprecision(2) << h1_custom.getAvgHits()
         << setw(18) << h2_custom.getCollisions()
         << setw(18) << fixed << setprecision(2) << h2_custom.getAvgHits() << endl;
    
    
    
    
    // hash function uniqueness 
    // set<uint64_t> hash1_values, hash2_values;
    // for (const auto& key : keys) {
    //     hash1_values.insert(Hash1(key));
    //     hash2_values.insert(Hash2(key));
    // }
    
    // cout << "\n" << string(89, '-') << endl;
    // cout << "Hash Uniqueness Verification:" << endl;
    // cout << "  Hash1 (MetroHash64): " << hash1_values.size() << "/10000 unique (" 
    //      << fixed << setprecision(1) << (hash1_values.size() / 100.0) << "%)" << endl;
    // cout << "  Hash2 (MurmurHash3): " << hash2_values.size() << "/10000 unique (" 
    //      << fixed << setprecision(1) << (hash2_values.size() / 100.0) << "%)" << endl;

    // cout << "Note : The Uniqueness tracks the initial uint_64 values generated by the hash functions,\nNot the indices"<<endl;
    
    
}
